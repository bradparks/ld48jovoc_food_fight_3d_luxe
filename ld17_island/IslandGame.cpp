#ifdef WIN32
#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#include <crtdbg.h>
#endif

#include "GLee.h"

#include <GL/gl.h>
#include <GL/glu.h>

#include <il/il.h>
#include <il/ilu.h>
#include <il/ilut.h>

#include <tinyxml.h>

#include <prmath/prmath.hpp>

#include "gamefontgl.h"
#include "IslandGame.h"

#include "debug.h"


IslandGame::IslandGame() :
	m_islandDrawBuf( NULL )
{
}

void IslandGame::updateSim( float dtFixed )
{
}

void IslandGame::update( float dt )
{
}

void IslandGame::redraw( )
{
	static bool gfxInit = false;
	if (!gfxInit)
	{
		initGraphics();
		gfxInit = true;
	}

	glClearColor( 0.3, 1.0, 1.0, 1.0 );
	glClear( GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT );

	// 3d stuff
	glEnable( GL_DEPTH_TEST );
	glEnable( GL_TEXTURE_2D );
	glEnable( GL_TEXTURE );

	glMatrixMode( GL_PROJECTION );
	glLoadIdentity();	

	gluPerspective( 50.0, 800.0/600.0, 0.1, 1000.0 );

	glMatrixMode( GL_MODELVIEW );
	glLoadIdentity();

	gluLookAt( 1.5, 10.0, -20.0,
			   0,0,0,
			   0.0, 1.0, 0.0 );

	static float ang = 0;
	glRotatef( ang, 0.0, 1.0, 0.0 );
	ang += 0.1;

	// draw some stuff the easy way
	glBindTexture( GL_TEXTURE_2D, m_terrainTilesTexId );	
	glBegin( GL_QUADS );
	
	glTexCoord2f( 0.0, 0.0 );
	glVertex3f( 0.0, 0.0, 0.0 );

	glTexCoord2f( 0.0, 1.0 );
	glVertex3f( 0.0, 0.0, 10.0 );

	glTexCoord2f( 1.0, 1.0 );
	glVertex3f( 10.0, 0.0, 10.0 );

	glTexCoord2f( 1.0, 0.0 );
	glVertex3f( 10.0, 0.0, 0.0 );

	glEnd();

	glEnable( GL_TEXTURE_2D );
	//glColor3f( 1.0, 0.0, 1.0 );	

	// Bind the island VBO
	glBindBuffer(GL_ARRAY_BUFFER, m_islandVBO);

	//glEnableVertexAttribArray( MapVert::ATTRIB_VERTEX);
	//glEnableVertexAttribArray( MapVert::ATTRIB_TEXCOORD );
	//glEnableVertexAttribArray( ATTRIB_NORMAL );
	
	//glVertexAttribPointer( MapVert::ATTRIB_VERTEX,   4, GL_FLOAT, GL_FALSE, sizeof(MapVert), 0);
	//glVertexAttribPointer( MapVert::ATTRIB_TEXCOORD, 2, GL_FLOAT, GL_FALSE, sizeof(MapVert), (void*)(3*sizeof(GLfloat)) );
	//glVertexAttribPointer( ATTRIB_NORMAL,   3, GL_FLOAT, GL_FALSE, sizeof(MapVert), (void*)(6*sizeof(GLfloat)) );
	
	//glBufferData( GL_ARRAY_BUFFER, sizeof(MapVert) * m_quadSize, 0, GL_STATIC_DRAW );
	//glVertexPointer( 4, GL_FLOAT, sizeof(MapVert), NULL );
	//

	glEnableClientState( GL_VERTEX_ARRAY );
	glVertexPointer( 3, GL_FLOAT, sizeof(MapVert), 0 );
	
	glEnableClientState( GL_TEXTURE_COORD_ARRAY );
	glTexCoordPointer( 2, GL_FLOAT, sizeof(MapVert), (void*)(4*sizeof(GLfloat)) );

	glDrawArrays( GL_QUADS, 0, m_quadSize*4 );
	

	glDisableClientState( GL_TEXTURE_COORD_ARRAY );
	glDisableClientState( GL_VERTEX_ARRAY );


	// 2D text and GUI stuff
	glDisable( GL_DEPTH_TEST );	
	
	glMatrixMode( GL_PROJECTION );
	glLoadIdentity();

	glMatrixMode( GL_MODELVIEW );
	glLoadIdentity();

	glDisable( GL_LIGHTING );		
	gfEnableFont( m_fntFontId, 32 );

	glColor3f( 1.0, 1.0, 1.0 );
		
	gfBeginText();
	glTranslated( 200, 200, 0 );		
	gfDrawString( "HELLO ISLAND WORLD..." );
	gfEndText();						

}

void IslandGame::initGraphics( )
{
	// Load Font	
	ilGenImages( 1, &m_ilFontId );
	ilBindImage( m_ilFontId );		
	
	if (!ilLoadImage( (ILstring)"gamedata/digistrip.png" )) {
		errorMessage("Loading font image failed\n");
	}
	
	// Make a GL texture for it
	m_glFontTexId = ilutGLBindTexImage();
	m_fntFontId = gfCreateFont( m_glFontTexId );

	// A .finfo file contains the metrics for a font. These
	// are generated by the Fontpack utility.
	gfLoadFontMetrics( m_fntFontId, "gamedata/digistrip.finfo");

	_RPT1( _CRT_WARN, "font has %d chars\n", 
		gfGetFontMetric( m_fntFontId, GF_FONT_NUMCHARS ) );					

	// Load the player sprite

	// Load the tiles
	m_terrainTilesTexId  = loadTexture( "gamedata/crappytiles.png" );

}

void IslandGame::loadLevel( const char *filename )
{
	TiXmlDocument *xmlDoc = new TiXmlDocument( filename );
	
	// clear the level
	clearLevel();

	if (!xmlDoc->LoadFile() ) {
		errorMessage("ERR! Can't load %s\n", filename );
	}

	TiXmlElement *xLevel;
	TiXmlNode *xText;

	xLevel = xmlDoc->FirstChildElement( "level" );
	assert( xLevel );

	// Get width and height
	TiXmlElement *xTag;
	xTag = xLevel->FirstChildElement( "width" );
	xText = xTag->FirstChild();
	m_mapSizeX = atoi( xText->Value() ) / 16;

	xTag = xLevel->FirstChildElement( "height" );
	xText = xTag->FirstChild();
	m_mapSizeY = atoi( xText->Value() ) / 16;

	// Load elevations
	TiXmlElement *xTile;
	TiXmlElement *xElevTiles = xLevel->FirstChildElement( "elevTiles" );
	
	xTile = xElevTiles->FirstChildElement( "tile" );	
	while (xTile) 
	{
		int id, xpos, ypos;
		id = atoi( xTile->Attribute( "id" ) );
		xpos = atoi( xTile->Attribute( "x" ) ) / 16;
		ypos = atoi( xTile->Attribute( "y" ) ) / 16;

		_RPT3( _CRT_WARN, "loc %d %d id %d\n", xpos, ypos, id );

		xTile = xTile->NextSiblingElement( "tile" );

		MapSquare &m = m_map[xpos][ypos];
		m.m_elevation = id;
		m.m_terrain = 0; // TODO get from terrain tileset
	}
}

void IslandGame::clearLevel()
{
	foreach_map_max
	{
		MapSquare &tile = MAPITER( m_map );
		tile.m_elevation = 0;
		tile.m_terrain = TERRAIN_EMPTY;
	}
}

void IslandGame::buildMap()
{
	if (m_islandDrawBuf)
	{
		free( m_islandDrawBuf );
	}
	

	//m_islandDrawBuf = (MapVert*)malloc( m_mapSizeX * m_mapSizeY * sizeof(MapVert) 

	m_quadSize = 0;
	m_quadCapacity = 0;

	DBG::info("buildMap: size %d %d\n", m_mapSizeX, m_mapSizeY );
	foreach_map
	{
		MapSquare &m = MAPITER( m_map );

		// Is this a blank or otherwise special tile?
		if (m.m_terrain < 0)
		{
			continue;
		}

		// Add a quad
		MapVert *newQuad = addQuad();

		// and fill it in
		const float tilesz = 1.0/16.0;
		int smap = m.m_terrain % 16;
		int tmap = m.m_terrain / 16;
		vec2f st = vec2f( smap * tilesz, tmap * tilesz );
		newQuad[0].pos = vec4f( mi, m.m_elevation + 1.0f, mj, 1.0f );
		newQuad[0].st  = st;

		newQuad[1].pos = vec4f( mi + 1.0f, m.m_elevation + 1.0, mj, 1.0f );
		newQuad[1].st  = st + vec2f( tilesz, 0.0f );

		newQuad[2].pos = vec4f( mi + 1.0f, m.m_elevation + 1.0, mj + 1.0f, 1.0f );
		newQuad[2].st  = st + vec2f( tilesz, tilesz );

		newQuad[3].pos = vec4f( mi, m.m_elevation + 1.0f, mj + 1.0f, 1.0f );
		newQuad[3].st  = st + vec2f( 0.0f, tilesz );
	}

	DBG::debug( "After buildMap, m_quadSize is %d\n", m_quadSize );

	// Make teh GL bufferses

	// TODO: free old buffers
	
	// Generate the vertex buffer object (VBO)
	glGenBuffers(1, &m_islandVBO );
	
	// Bind the VBO so we can fill it with data
	glBindBuffer(GL_ARRAY_BUFFER, m_islandVBO);
	
	// Set the buffer's data
	// Calc afVertices size (3 vertices * stride (3 GLfloats per vertex))
	unsigned int uiSize = sizeof( MapVert ) * m_quadSize * 4;
	glBufferData(GL_ARRAY_BUFFER, uiSize, m_islandDrawBuf, GL_STATIC_DRAW);	
	
	DBG::info("NumQuads %d size %d\n", m_quadSize, uiSize );
}

MapVert *IslandGame::addQuad()
{
	MapVert *newQuad;

	// Do we need to make more space for this quad??
	// NOTE: potentially confusing: size/capacity is in # of verts,
	// not num quads
	if (m_quadSize + 4 >= m_quadCapacity)
	{
		// increase capacity
		int m_quadTargetCapacity;
		if (m_quadCapacity==0)
		{
			// start with 8192 because it's a nice number
			m_quadTargetCapacity = 8192;
		}
		else
		{
			m_quadTargetCapacity = m_quadCapacity * 2;
		}

		DBG::debug("Grow quadbuff to new capacity %d\n", m_quadTargetCapacity );
		MapVert *newBuff = (MapVert*)calloc( m_quadTargetCapacity, 
											  sizeof( MapVert ) );

		// copy over existing if needed
		if (m_islandDrawBuf)
		{
			memcpy( newBuff, m_islandDrawBuf, sizeof(MapVert) * m_quadSize );
			free( m_islandDrawBuf );
		}
		m_islandDrawBuf = newBuff;
		m_quadCapacity = m_quadTargetCapacity;
	}

	// Ok, now we know there's space for the new quad
	newQuad = &m_islandDrawBuf[m_quadSize];
	m_quadSize += 4;

	return newQuad;
}

GLuint IslandGame::loadTexture( const char *filename )
{
	// Load the font image
	ILuint ilId;
	ilGenImages( 1, &ilId );
	ilBindImage( ilId );		
	
	if (!ilLoadImage( (ILstring)filename )) 	
	{		
		errorMessage( "Loading texture failed for: %s", filename );
	}
	
	// Make a GL texture for it
	GLuint glTexId;
	glTexId = ilutGLBindTexImage();
	
	return glTexId;
}